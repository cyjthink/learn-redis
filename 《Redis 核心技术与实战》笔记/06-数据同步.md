1. 主从库模式：保证数据副本的一致。主从库之间采用的是读写分离
2. 读写分离
   1. 读操作：主库、从库都可以接收
   2. 写操作：首先在主库执行，然后主库将操作同步到从库
3. 为什么采用读写分离？ 假设主从库都可以进行写操作，实例间的数据可能不同步。为了实现同步需要涉及加锁操作，这会带来巨大开销
4. 如何建立主从库？在从库上运行：replicaof 主库ip地址 6379
5. 主从库间如何进行第一次同步？（全量复制）
   1. 从库和主库建立连接，并告诉主库即将开始同步。主库确认回复后主从库间就开始同步
   2. 主库同步数据(RDB)给从库，从库收到数据后完成数据加载
   3. 主库把步骤2执行时新收到的命令发给从库
6. 如果多个从库都与主库进行全量复制，主库压力很大。采用"主-从-从"模式的主从级联分散主库的压力
7. 基于长连接的命令传播：一旦完成全量复制后，主从库间会一直维护一个连接。主库会通过这个连接将收到的新命令同步给从库
8. 主从库间网络连接中断怎么办？主库只把断联期间收到的命令同步给从库（增量复制）
9. repl_backlog_buffer的理解：用于主从库之间的增量同步
   1. 它是为了主从库断开连接后，如何找到主从库差异数据而设计的环形缓冲区，从而避免全量复制带来的性能开销
10. replication buffer的理解：用于主节点与各个从节点之间数据的交互
    1. redis与每个客户端、从库通信都会分配一个buffer。通常redis会先把命令写到buffer中，再通过把buffer发送到client socket中通过网络发送出去。而这个buffer专门用来传播写命令到从库
    2. 为什么设计buffer？避免频繁的调用发送。即当buffer满了再发送的性能大于每byte就发送
11. 如何判断该同步哪个区间的命令？指向环形缓冲区repl_backuplog_buffer的master_repl_offset（主库）和slave_repl_offset（从库）
12. 主从库间数据不一致：repl_backuplog_buffer是个环形缓冲区，当缓冲区写满后之前的数据会被覆盖。当从库读取速度较慢，可能导致从库还未读取的操作被主库新写的操作覆盖
13. 当从库的slave_repl_offset在主库上的位置已经被覆盖时，从库会进行全量复制
14. 主从库间的同步可分为：全量复制、基于长连接的命令传播、增量复制
15. 建议：redis实例的大小在几个GB级别比较合适，这样可以减少在生成RDB文件、传输和重新加载的开销